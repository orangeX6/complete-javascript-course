//-> THEORY LECTURES

// 246. Asynchronous JavaScript, AJAX and APIs
//>> Coordinating behavior of a program over a period of time
//>> Asynchronous means not occurring at the same time
//-> Asynchronous code is executed after a task that runs in the "background" finishes.
//-> Asynchronous code is  'non-blocking'
//-> Execution doesn't wait for an asynchronous task to finish its work.

//Example of asynchronous code in js
//* 1. Asynchronous image loading with event and callback
//img.src -> loading of image happens asynchronously
//we provide the callback function to the load event to call the function once the image is loaded and not right away
//* 2. Geolocation API or AJAX calls, etc
//? Callback functions alone do NOT make code asynchronous

//////////////////////////////////////////////////
//-> >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//->> AJAX
//>> Stands for Asynchronous Javascript And XML.
//-> Allows us to communicate with remote web servers in an asynchronous way.
//-> With AJAX calls, we can REQUEST DATA from web servers dynamically

//?HOW AJAX WORKS ?
//? Client <====Request/Response====> Webserver

//? AJAX is a term which got popular back and so we still use it. But most apis don't use XML data format these days
//-> Most popular API data format now is JSON

//////////////////////////////////////////////////
//-> >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
//->> API
//>> Stands for Application Programming Interface.
//-> A piece of software that can be used by another piece of software, in order to allow applications to talk to each other
//Example - DOM API, Geolocation API, etc.

//? "Online" API - Application running on a server, that receives requests for data, and sends data back to response.
//? We simply call these APIs or WebAPIs

//There are APIs about everything. Example ->
// For travelling app you can get an api for
//* Weather data
//* Data about countries
//* Flights Data
//* Currency conversion data
//* APIs for sending email or SMS
//* Google Maps
//There are millions of possibilities

//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////
//////////////////////////////////////////////

// 247. IMPORTANT: API URL Change
//-> USE THIS
// https://restcountries.com/v2/
// https://restcountries.com/v3.1/name/{name}

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

// 248. Our First AJAX Call: XMLHttpRequest
//? There are multiple ways to do AJAX calls
//>> We will use XMLHttpRequest in this lecture
//! Any API we use here should always have CORS set to yes or maybe unknown, without CORS we cannot access a third party API into our own code
// We will be using the Rest Countries API
//-> https://github.com/public-api-lists/public-api-lists
//>> CORS - Cross Origin Resource Sharing

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

// 249. [OPTIONAL] How the Web Works: Requests and Responses
//-> The request response model or Client-Server Architecture
//>> A browser as a client sends request to a server and then the server sends response, and that response contains the data that we requested.

//https://  restcountries.com/  v2/alpha/IN
//  |             |                 |
//Protocol      Domain Name     Resource
//(http or https)

//-> What happens when we access a web server
//-> 1.
// Domain Name is converted to real address of server with the help of DNS(Domain Name Server).
//Browser makes request to DNS which sends the IP address as response

//-> 2.
// TCP/IP Socket Connection connects the client to the Web Server with its IP Addr
//TCP - Transmission Control Protocol
//IP - Internet Protocol

//-> 3.
//Once communication is established - HTTP Request is made by the client to the server.
//HTTP - Hyper Text Transfer Protocol
// The request looks like ->
//* GET /rest/v2/alpha/IN HTTP/1.1 <- Start Line: Method + request target + HTTP version
//? Host: www.google.com      -\
//? User-Agent: Mozilla/5.0   --> HTTP Request Headers
//? Accept-Language: en-US    -|
//// <BODY>  -> REQUEST BODY (ONLY WHEN SENDING DATA TO SERVER)

//>> Most important HTTP Methods are ->
//>> 1. GET - Requesting Data
//>> 2. POST - Sending Data
//>> 3. PUT - Modifying Data
//>> 4. PATCH - Modifying data

//Difference Between HTTP and HTTPS -
//HTTPS is encrypted using TLS or SSL

//-> 4.
// HTTP RESPONSE Is the response sent by the server in response to the request send by client.

//The response looks like -
//* HTTP/1.1 200 OK -> HTTP version + status code + status msg
//? Date: fri, 18 jan 2021
//? Content Type: text/html
//? Transfer-encoding: chunked
//// <BODY>

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

// 250
//-> Call Back Hell -
//>> Call back hell is when we have a lot of nested call backs in order to execute asynchronous tasks in sequence.
// This happens to all asynchronous tasks which are handled by callbacks
//It makes code hard to maintain
//-> Since ES6 there is a way to escape the callback Hell and its promises.

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

//251
//251. Promises and the Fetch API
//-> PROMISE: (ES6 2015)
//>>Definition. An Object that is used as a placeholder for the future result of an asynchronous operation
//->Simple terms: A container for an asynchronously delivered value
//>>More Simple Terms: A container for a future value
//*EXAMPLE - Response from AJAX call

//? Advantages of Using Promises ?
//? 1. We no longer need to rely on events and callbacks passed into asynchronous functions to handle asynchronous results
//? 2. Instead of nesting callbacks, we can chain promises for a sequence of asynchronous operations: escaping callback hell

//>> HOW WE USED AJAX CALLS
// const request = new XMLHttpRequest();
// request.open(
//   'GET',
//   `https://restcountries.com/v2/name/${country}?fullText=true`
// );
// request.send();

//>> WHAT WE HAVE TO DO IN PROMISES
const request = fetch(`https://restcountries.com/v2/name/India?fullText=true`);
console.log(request); // outputs Promise Object

//-> PROMISE LIFECYCLE

//* PENDING --async task----> SETTLED
//*                          /    \
//->                 FULFILLED     \
//!                              REJECTED
// We are able to handle these different states in our code

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

// 254. Handling Rejected Promises
//? There are two ways of handling rejections -
//* 1. Passing a second callback to the then method
//! .then(
//!   response => response.json(),
//!   err => alert(err)
//! )
//* 2. Using the catch method at the end of the promise chain
//->  .catch(err => alert(err));

//? Finally block is executed no matter what, i.e if promise is fulfilled or not
// .finally(() => {
//     countriesContainer.style.opacity = 1;
//   })

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

//255. Throwing error manually
//-> We use throw keyword to throw errors manually
// throw new Error('Country not found')

// We create an error using the error constructor function (new Error())
//-> We use the throw keyword which will immediately terminate the execution of current function just like return
//? The effect of creating and throwing error in any of the then method is that the promise will immediately be rejected

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

// 257. Asynchronous Behind the Scenes: The Event Loop
//>>Components of Javascript Runtime Env -
//>> 1. JavaScript Engine
//*     1.1 HEAP
//*     2.2 CALL STACK
//>> 2.  Callback queue
//>> 3.  Event Loop
//>> 4.  Web APIs
//*     4.1 DOM
//*     4.2 Timers
//*     4.3 FetchAPI
//*     4.4 etc....

//? JS only has one thread. How can the asynchronous code be executed in a non blocking way if there is only one thread of execution in the engine?
//-> WEB APIs Environment is where asynchronous tasks run.
//>> Async tasks examples - timers, ajax calls, load image, etc

//>> Callbacks related to promises do not actually go to the callback queue.
//-> Callbacks of promises have a special queue for themselves which is called as MICRO TASKS QUEUE.
//-> The special thing about MICRO TASKS QUEUE is that it has priority over the CALLBACK QUEUE.
//-> We call the callbacks from promises as micro tasks and therefore the name MicroTasks Queue
//>> The event loop prioritizes MicroTasks queue over the callback queue and hence if there are like too many MicroTasks then they can basically starve the callback queue. This is not a problem usually, just FYI.

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

// 259. Building a Simple Promise

//>> We create new promise using the promise constructor.
//* Promises are just a special kind of object in JS
//-> Takes one argument i.e executor function
//*  As soon as the promise constructor runs, it will automatically execute the executor function.
//* And as it executes this function, it will do so by passing in two other arguments.
//* And those arguments are the resolve and reject functions.

//-> PROMISIFYING
//>> Promisifying means to convert callback based asynchronous behavior to promise based.

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

// 262. Consuming Promises with Async/Await
// 263. Error Handling With try...catch
// 264. Returning Values from Async Functions

//-> Since ES 17 there is an easier way of consuming promises, and that is async/await

//>> Inside a async function we can have one or more await
//? Its just a syntactic sugar over the then method.
//? fetch(`https://restcountries.com/v3.1/name/${country}?fullText=true`).then(res=> console.log(res);)

//-> Since async function returns a promise we can use then on it to get the returned value
////Even if the async function fails, it will still fulfill the promise and hence then will be executed no matter what.
//// To fix this we have to manually reject promise from catch block of async function
//? And we do that by re-throwing the error from catch so that we can propagate it down.

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

// 265. Running Promises in Parallel
// 266. Other Promise Combinators: race, allSettled and any

//->> Promise.all
//-> Promise.all() is a COMBINATOR METHOD
//-> Promise.all() - Takes an array of promises and returns a new promise which will then run all the promises in the array at the same time
//! Promise.all() short circuits when one promise rejects

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

//->> 1. Promise.race
//>> Receives in an array of promises, and returns a promise. This promise returned by promise.race is settled as soon as one of the input promise settles.
//>> So in promise.race basically the first settled promise wins the race.
//! Settles means when a value is returned. It doesn't matter whether the promise is fulfilled or rejected

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

//->> Promise.allSettled (ES 2020)
//>> It takes in an array of promises and returns and it will simply return an array of all the settled promises.
//? No matter if the any of the promises got rejected or not
//* Its SIMILAR to PROMISE.ALL in regards that it also returns an array of all the results, BUT the DIFFERENCE is that PROMISE.ALL will short circuit as soon as 1 promise rejects, but promise.all settled simply never short circuits.

/////////////////////////////////////////////////
/////////////////////////////////////////////////
/////////////////////////////////////////////////

//->> Promise.any (ES 2021)
//>> Promise.any takes in an array of multiple promises and then returns the first fulfilled promise
//* It will simply ignore rejected promise
