Complete JS 
JS 
Scripting language 
Compile time language
Uses Just in time compiling
Client side as well as server side code 

Adds interactivity to your website

Founded by - Brendan Eich (Co founder of Mozilla)
Dynamic Programming Language (Run time compilation)
Compact and Flexible 

Application Programming Interfaces (API)


var i = 0; i++        // <-- semicolon obligatory
                      //     (but optional before newline)
var i = 0             // <-- semicolon optional
    i++               // <-- semicolon optional
    
    
Variables - var,let,const
var - function scope
let - block scope


Comments - // /* */




Type conversion and type coercion
conversion is when we manually convert from one type to another
coercion is when java script automatically convert types behind the scenes for us.


Mathematical Operators - +, -, *, %, /
Assignment operators -  =, +=, -=,*=, ++,--
Comparison operators - > , < , <=, >= ,  
Equality Operators -  ===, !, !==
Logical Boolean Operatorss - AND, OR, NOT

=== -> Strict eequality. does not allow coercion;
== -> Allows coercion


Conditionals ->  if,if..else, ternary

Since ternary operator is an expression we can use it template literal, unlike if else

JS has 5 falsy values - 0, '', undefined, null, NaN






Functions 
Difference between argument and parameter - parameter is the placeholder in the function where as the argument is the actual value that is passed to the function.
Function Declaration can be called before they are defined in the code. We can call it first and then define.
In function expression we cannot call it first and then define.

Arrow functions are great for a quick one line code. They dont have "this" keyword.
Arrow functions dont have argument objects and this keyword.

Events (Listen for activity in the browser)

For avoiding errors when script in head 
Internal JS - <script> 
			document.addEventListener("DOMContentLoaded", function () {})
		   </script>
External JS - Async and defer. Ezample - <script src="script.js" defer></script>









Biggest Difference between var and let - 
var - Supports Hoisting (Declaring a variable after use)
let 
const 

Strict mode - The purpose of "use strict" is to indicate that the code should be executed in "strict mode".
With strict mode, you can not, for example, use undeclared variables.You can use strict mode in all your programs. It helps you to write cleaner code, like preventing you from using undeclared variables.
As an example, in normal JavaScript, mistyping a variable name creates a new global variable. In strict mode, this will throw an error, making it impossible to accidentally create a global variable.

typeof - returns type of variable. Eg - number, String, etc.










Strings - 

length
indexOf
slice
toLowerCase
toUpperCase
replace

stringName.length
stringName.indexOf('stringPart')
stringName.slice(0,3)
stringName.toLowerCase();
stringName.toUpperCase();
stringName.replace('moz','van');











Arrays

let shopping = ['bread', 'milk', 'cheese', 'hummus', 'noodles'];
let sequence = [1, 1, 2, 3, 5, 8, 13];
let random = ['tree', 795, [0, 1, 2]];


split
toString
join

push and unshift - add to array
pop and shift - remove from array

friends.push('Rosh'); //adds element to the end of the array
friends.unshift('Akash') // add element to the beginning of the array
friends.shift(); //removes the first element
friends.pop() // removes the last element

//In dot notation we have to use the real property name and can not use the expression.
// we can also store an expression in bracket notation which can hold the key 
//For eg 
const nameKey = 'Name'
console.log(Pranav['first' + nameKey]);
console.log(Pranav['last' + nameKey]);

//When we need to compute the property name we have to use the bracket notation.In other cases we use the dot notation mostly











DOM - Document Object Model - Is a structural representation of HTML documents. Allows Javascript to access 
HTML elements and styles to manipulate them.
Document - special element that is the entry point to DOM. Example - document.querySelector()
DOM is not actually the part of javascript. It is a part of Web APIs that browser use from where we can access our JS code.









//WE DONT HAVE TO WRITE BRACKETS FOR ONE LINE OF LOOP
EG - for (let i = 0; i < btnOpenModal.length; i++)
        console.log(btnOpenModal[i].textContent);

addEventListener()
removeEventListener()

//KEYBOARD EVENTS ARE GLOBAL EVENTS, BECAUSE DO NOT HAPPEN ON ONE
// SPECIFIC ELEMENT, AND FOR GLOBAL EVENTS LIKE KEYBOARD EVENTS, WE LISTEN ON
// WHOLE DOCUMENTS
Keyboard events - 1. keydown 2.keypress 3. keyup

GET ELEMENT BY ID - 

const score0 = document.querySelector('#score--0');
const score1 = document.querySelector('#score--1');

//THE ABOVE CAN ALSO BE WRITTEN AS
const score0 = document.getElementById('score--0');
const score1 = document.getElementById('score--1');
//getElementById is faster than querySelector. We dont need to 
use the # symbol in getElementById













//HOW JAVASCRIPT WORKS _ 
JS is a high level, object oriented, multi paradigm programming language



High Level 

What is a Javascript engine? 
A computer program that simply executed js code.
Every browser has its own JS engine. 
Chrome uses the V8 engine. It also powers nodeJS.
Every JS engine contains 
1 . Callstack 
2. Heap

1. Callstack - 
where our code is executed 
2. Heap - 
Unstructured memory pool where objects are stored.


Compilation vs Interpretation
Compilation - entire code is converted into machine code at once, and written to a binary file that can be executed by a computer, way later than its compilation.

	Source code --Compilation-- > Portable File: Machine code-- Execution--> Program running. 

Interpretation - Interpreter runs through the source code line by line. code is written and executed all at the same time.
 Source code ------Execution line by line----> Program running.
 
Previously JS used to be a fully interpreted language, but interpreted languages are slow.

Now JS uses a combination of both compilation and interpretation, i.e., Just in time compilation (JIT).

Entire code is converted into machine code at once, then executed immediately. 
Source code --Compilation-- >  Machine code-- Execution--> Program running.
This is lot faster than executing code line by line

JIT compilation 
 			Parsing (Parse basically is - Read the code)
 		(Abstract Syntax Tree)
				|
				V
			Compilation
				|	
				V
			Execution
		(Happens in call stack)
		
APIs are functionality provided to the engine but are not actually a part of Javascript itself.
Javascript simply gets access to these APIs through the global window object.
But it still makes sense that the APIs are still part of the runtime, because a runtime is just like a box that contains all the javascript related stuff that we need.
A typical javascript runtime also includes a so called javascript callback queue.
Its a data structure that contain all the callback functions that are ready to be executed. 
For eg - click, timer, data ... 
APIs eg - web apis, c++ threads,binding in nodeJS 

COMPONENTS OF EXECTION CONTEXT - 
VARIABLE env
SCOPE CHAIN
THIS Keyword

Scopes - 
Global scope, Function Scope, Block Scope(ES6)
Const and let and functions(in strict) declared in block have scope of that block.
let and const are block scoped
var is function scoped

Hoisting - Makes some types of variables accessible/usable in the code before they are actually declared. 

Before Execution - code is scanned for variable declarations and for each variable, a new property is created in the variable env obj. 

Temporal Dead Zone - 
Zone where if u use const and let before initialization will give u an error.
WHY TDZ ? - Makes easier to avoid and catch errors.
		  - Make const variables actually work.

Variables declared with var will create a property on the global window object. Let and const won't.

THIS KEYWORD - Special variable that is created for every Execution context(every function).
- Takes the value of(points to) the "OWNER" of the function in which the THIS KEYWORD is used 
- THIS is NOT static. IT depends on how the function is called, and its value is only assigned when the function is actually called.

Method ðŸ‘‰ this = 				<Object that is calling the method>
Simple function call ðŸ‘‰ this = 	undefined(In strict mode, Otherwise window(in the browser))
Arrow functions ðŸ‘‰ this = 		<this of surrounding function.(lexical this)>
Event Listener ðŸ‘‰ this = 		<DOM element that the handler is attached to>
new,apply,call,bind ðŸ‘‰ this = 	? ? ?

- This does NOT point to the function itself, and also NOT the variable environment.


//PRIMITIVES VS OBJECTS(PRIMITIVES VS REFERENCE TYPES)

//Copying objects (Objects.assign(obj,objToBeCopied) method)
//There is still a problem in using Object.assign(). It only creates a shallow copy i.e. it only works on first level. For example if we have an object inside an object then the inner object will still be the same i.e. it will still point to the same place in memory.

// We want to create a deep clone and not a shallow copy. A shallow copy will only copy the properties on the first level while the deep copy will copy everything.
//One way this can be achieved is by using lodash, an external library. 

SPREAD OPERATOR - 
//Spread operator expands the array into all its elements, basically unpacking all the array elements at once.

//WITHOUT SPREAD OPERATOR
const arr = [7, 8, 9];
const badNewArr = [1, 2, arr[0], arr[1], arr[2]];
console.log(badNewArr); //outputs [1, 2, 7, 8, 9]
//WITH SPREAD OPERATOR
const newArr = [1, 2, ...arr];
console.log(newArr); //outputs [1, 2, 7, 8, 9]
//When we need the individual elements of the array we use spread operator, and that is useful when we write an array and we pass multiple elements into a function
//Difference in array destructuring and spread operator is spread operator takes all the elements out from the array and doesnt create new variables and as a consequence we can only use it in places where we write values seperated by commas.
//We can use Spread operator on all Iterables: arrays, strings,maps,sets.
//Since 2018 spread operator also works on objects
//Wont work in template literals -
//Ex this wont work  - console.log(`${..str} abc`);

//SAME SYNTAX AS SPREAD OPERATOR BUT DOES THE OPPOSITE THING.

//SPREAD is used on the right side of assignment operator
const arr = [1, 2, ...[3, 4]];

//REST is used on the left side of assignment operator
const [a, b, ...others] = [1, 2, 3, 4, 5];
console.log(a, b, others); //outputs 1 2 (3)Â [3, 4, 5]

//It does not include the skipped element, hence the rest pattern must be the last element

//Spread and the rest syntax both look exactly the same.
// But they work in opposite ways depending on where they are used.
// The spread operator is used where we would otherwise write values separated by comma
//The rest pattern is used where we would otherwise write variable names separated by comma and not values.

//9.6 THE NULLISH COALESCING OPERATOR (??)
restaurant.numGuests = 0;
const guests = restaurant.numGuests || 10;
console.log(guests); //outputs 10

//As we can see the result is wrong as if there are 0 guests the output should be 0. The solution to this is a new operator in ES 2020 i.e. the NULLISH COALESCING OPERATOR (??)

//The NULLISH COALESCING operator works with the idea of nullish values instead of falsy values.
//NULLISH VALUES are null and undefined. So it does not include (NOT, 0 or ' ' );
const guestCorrect = restaurant.numGuests ?? 10;
console.log(guestCorrect); //outputs 0

FOR OF Loop
Ex - for (const item of menu) console.log(item);
//FOR OF allows continue and break;
//Some ways of looping arrays wont allow you to do so

//9.10 ENHANCED OBJECT LITERALS
//1 Adding an existing object can be done with a better syntax
//2 Methods can be written without function keyword
//3 We can compute property names instead of writing them out manually


//9.11 OPTIONAL CHAINING (.?)
//With optional chaining if a certain property does not exist then undefined is returned immediately

  console.log(restaurant.openingHours.mon.open);    
  //The above will give the following error. 
  //Uncaught TypeError: Cannot read properties of undefined (reading 'open')

  //WITH OPTIONAL CHAIN  (?.)
  console.log(restaurant.openingHours.mon?.open); //returns undefined
//Only if the property that is before the '?' exists then the property after it will be read. Else it will return undefined 

//9.12 LOOPING OBJECTS: OBJECT KEYS, VALUES, and ENTRIES

//SETS 
//A set is just a collection of unique values.
//Set can never have duplicate values.
//All the duplicate values are removed
//Set vs Array
// In set order of element  is irrelevant.
//All elements in set are unique
//There are no indexes in set
//There is no way of getting values out of set. Thats because there is no need to get data out of set as all values are unique and their orders does not matter and there is no point in retrieving values out of set. All we need to know is if a value is present in set or not
//The main use case of set is to remove duplicate values of arrays
//Has method in set is equivalent to include method in arrays

//Set methods -
//has,delete,add,clear

//MAPS 
// A map is a data structure used to map values to keys.
//Just like objects data is stored in key value pair in maps
//The difference between map and objects is that in maps the keys can have any type. Even arrays or objects
//Map Methods -  set,delete,has,size,get

//9.17 SUMMARY: WHICH DATA STRUCTURE TO USE?



//9.17 SUMMARY: WHICH DATA STRUCTURE TO USE?

// DATA STRUCTURES OVERVIEW 
// ðŸš… SOURCES OF DATA 
// 1 FROM THE PROGRAM ITSELF 
// 2 FROM THE UI 
// 3 FROM THE EXTERNAL SOURCES (APIs) 

//WHAT IS AN API ? 
// API stands for Application Programming Interface and we can use the API to get data from other web applications. 
//For eg. we can use the API to get weather info on any city, data about movies, currency conversion rates, etc 

//SOURCES OF DATA => COLLECTION OF DATA ==Store in ==>DATA STRUCTURE 

//DATA STRUCTURES IN JS 
//ARRAYS 
//OBJECTS
//MAPS
//SETS
//WEAK MAP
//WEAK SET

//NOT BUILT IN 
//STACKS
//QUEUES
//LINKED LIST
//TREES
//HASH TABLES

//WHICH DATA STRUCTURE TO USE ? 
//Do we need a simple list of values ? 
//We ll useARRAYS or SETS 
//Do we need Key/Value Pairs ? 
//We ll use OBJECTS or MAPS 

//WHEN TO USE ARRAYS ?
//- When you need ORDERED list of values
//- Use when you need to MANIPULATE data

//WHEN TO USE SETS
//-When you need to work with UNIQUE values
//- HIGH PERFORMANCE is important
//- REMOVE DUPLICATES from arrays

//WHEN TO USE OBJECTS 
//-  More TRADITIONAL Key/Value store
//- Easier to write and access values with . and []
//- When you need to include FUNCTIONS (METHODS)
//- When working with JSON  (Can convert to MAP)

//WHEN TO USE MAPS
//-  BETTER PERFORMANCE 
//- KEYS can have ANY data type
//- EASY TO ITERATE
//- EASY TO COMPUTE SIZE
//- When you simply need to map key to values
//- Use when you need keys that are NOT strings



//9.19 WORKING WITH STRINGS - PART 1
//STRINGS ARE PRIMITIVES
//SO WHY DO THEY HAVE METHODS ?
//SHOULD'NT METHODS BE JUST AVAILABLE ON OBJECTS, SUCH AS ARRAYS ?
//WHENEVER WE CALL A METHOD ON A STRING, JS WILL AUTOMATICALLY BEHIND THE SCENES CONVERT THAT STRING PRIMITIVE TO STRING OBJECT WITH THE SAME CONTENT AND THEN ITS ON THAT OBJECT THAT THE METHODS ARE CALLED.
//THIS PROCESS IS CALLED BOXING BECAUSE IT BASICALLY TAKES OUR STRING AND PUTS IT IN A BOX WHICH IS THE OBJECT AND THEN AGAIN CONVERTS THE RESULT TO PRIMITIVE TYPE

//LIST OF STRING METHODS USED  -
//1 indexOf
//2 lastIndexOf
//3 trim
//4 slice
//5 toUpperCase
//6 toLowerCase
//7 trimStart
//8 trimEnd
//9 replace - only replaces first occurrence
//10 replaceAll
//11 split
//12 join
//13 padStart
//14 padEnd
//15 repeat
//BOOLEAN METHODS -
//1.1 includes
//1.2 startsWith
//1.3 endsWith



Garbage Collected

Interpreted or just-in-time compiled

Multi-Paradigm - 
	1. Procedural programming
	2. Object oriented programming
	3. Functional Programming


Prototype-based Object-oriented
	1. Almost everything in js is an object. 


First Class Functions
In a language with first class functions, functions are simply treated as variables. We can pass them into other functions, and return them from functions.

Dynamic
Dynamically-typed Language: 
No data type definitions. Types becomes known at runtime. Data type of variable is automatically changed.

If you want to use javascript as a strongly type languagge then you should learn about Typescript

Single Threaded


Non-blocking event loop concurrency model - 
Concurrency model : How the javascript engine handles multiple tasks happening at the same time.

Why we need it ? - coz js runs in one single thread, so it can only do one thing at a time.

So what about long running task?
Sounds like it would block the single thread. However, we want non blocking behavior!

How do we achieve that ? 
By using an event loop : takes long running tasks, executed them in the background, and puts them in the main thread once they are finished.





















Abort Signal
const controller = new AbortController()
controller.abort();

 e.stopPropagation();
 
 
encapsulation 
stored inside an object package
  
abstraction 

instantiation

polymorphism

inheritance


Constructors and Object instances 
Constructor function name usually starts with a capital letter.

Function constructor
function Person(name) {
	this.name = name;
	this.greeting = function() {alert('Hi I am ' + this.name)}
}

Object Constructor
let person1 = new Object();

let person1 = new Object({
  name: 'Chris',
  age: 38,
  greeting: function() {
    alert('Hi! I\'m ' + this.name + '.');
  }
});




Using create method 
create()

let person2 = Object.create(person1);



Prototypes - mechanism by which js objects inherit features from one another 
An object's prototype object may also have a prototype object, 
which it inherits methods and properties from, and so on. This is often referred to as a prototype chain, 
and explains why different objects have properties and methods defined on other objects available to them.
__proto__ 


JSON - JavaScript Object Notation
Converting a string to a native object is called deserialization, 
while converting a native object to a string so it can be transmitted 
across the network is called serialization.

XMLHttpRequest - XHR - API to call JSON 
we use an API called XMLHttpRequest (often called XHR). This is a very useful JavaScript object 
that allows us to make network requests to retrieve resources from a server via JavaScript
 (e.g. images, text, JSON, even HTML snippets), 
meaning that we can update small sections of content without having to reload the entire page



A thread is basically a single process that a program can use to complete tasks.


Each task will be run sequentially; a task has to complete before the next one can be started.

As we said earlier, many computers now have multiple cores, so can do multiple things at once. 
Programming languages that can support multiple threads can use multiple
cores to complete multiple tasks simultaneously